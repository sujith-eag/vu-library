
# Exception Handling


#### Exception Hierarchy

In Java, all exceptions are represented by classes. 

All exception classes are derived from a class
called Throwable. Thus, when an exception occurs in a program, an object of some type of
exception class is generated. 

There are two direct subclasses of Throwable: Exception and Error. 

Exceptions of type Error are related to errors that occur in the Java Virtual Machine itself, and not in your program. These types of exceptions are beyond your control, and your program will not usually deal with them. Thus, these types of exceptions are not described here.


Errors that result from program activity are represented by subclasses of Exception.
For example, divide-by-zero, array boundary, and file errors fall into this category. In general,
your program should handle exceptions of these types. An important subclass of Exception is
RuntimeException, which is used to represent various common types of run-time errors.


Exceptions are generated in three different ways. First, the Java Virtual Machine can
generate an exception in response to some internal error which is beyond your control.
Normally, your program won’t handle these types of exceptions. Second, standard
exceptions, such as those corresponding to divide-by-zero or array index out-of-bounds, are
generated by errors in program code. You need to handle these exceptions. Third, you can
manually generate an exception by using the throw statement. No matter how an exception
is generated, it is handled in the same way.


#### Exception Handling Fundamentals

Java exception handling is managed via five keywords: try, catch, throw, throws, and
finally.

They form an interrelated subsystem in which the use of one implies the use of
another. 


Program statements that you want to monitor for exceptions are contained within a `try` block. 

If an exception occurs within the try block, it is thrown. Your code can catch this exception using `catch` and handle it in some rational manner.

System-generated exceptions are automatically thrown by the Java run-time system. To manually throw an exception, use the keyword `throw`.

In some cases, an exception that is thrown out of a method must be specified as such by a `throws` clause. 

Any code that absolutely must be executed upon exiting from a try block is put in a `finally` block.


#### Using try and catch

At the core of exception handling are try and catch. These keywords work together; you can’t have a catch without a try.
```java
try {
	// block of code to monitor for errors
}
catch (ExcepType1 exOb) {
	// handler for ExcepType1
}
catch (ExcepType2 exOb) {
	// handler for ExcepType2
}
```


Here, ExcepType is the type of exception that has occurred. When an exception is thrown, it is
caught by its corresponding catch statement, which then processes the exception. As the general
form shows, there can be more than one catch statement associated with a try. The type of the
exception determines which catch statement is executed. That is, if the exception type specified
by a catch statement matches that of the exception, then that catch statement is executed (and all
others are bypassed). When an exception is caught, exOb will receive its value.

There is another form of the try statement that supports automatic resource
management. This form of try is called try-with-resources.

___

```java
class ExecDemo
{
	public static void main(String[] args)
	{
		int[] nums = new int[4];
		
		try
		{
			System.out.println("Before exeption is generated.");
			num[7] = 10; // out of bound
			System.out.println("This wont display");
		}
		catch(ArrayIndexOutOfBoundsExeption exec)
		{
			System.out.println("Index out-of-bounds!");
		}
		System.out.println("After catch statement.");
	}
}
```

```
Before exception is generated.
Index out-of-bounds!
After catch statement.
```

catch is not called.
Rather, program execution is transferred to it. Thus, the println( ) statement following the out-of-
bounds index will never execute. After the catch statement executes, program control continues
with the statements following the catch. Thus, it is the job of your exception handler to remedy
the problem that caused the exception so that program execution can continue normally.

if no exception is thrown by a try block, no catch statements will be executed
and program control resumes after the catch statement.

#### Consequence of Uncaught Exception

In general, if your program does not catch an exception,
then it will be caught by the JVM. The trouble is that the JVM’s default exception handler
terminates execution and displays a stack trace and error message.

he type of the exception must match the type specified in a catch
statement. If it doesn’t, the exception won’t be caught.

#### Handling Errors Gracefully

One of the key benefits of exception handling is that it enables your program to respond
to an error and then continue running.

```java
// Handle error gracefully and continue.
class ExcDemo3 
{
	public static void main(String[] args) 
	{
		int[] numer = { 4, 8, 16, 32, 64, 128 };
		int[] denum = { 2, 0, 4, 4, 0, 8 };
		for(int i=0; i<numer.length; i++) 
		{
			try 
			{
				System.out.println(numer[i] + " / " +
				denom[i] + " is " +
				numer[i]/denom[i]);
			}
			catch (ArithmeticException exc) 
			{
				// catch the exception
				System.out.println("Can't divide by Zero!");
			}
		}
	}
}
```


```
4 / 2 is 2
Can't divide by Zero!
16 / 4 is 4
32 / 4 is 8
Can't divide by Zero!
128 / 8 is 16
```

If a division by zero occurs, an ArithmeticException is generated. In the program, this exception is handled by reporting
the error and then continuing with execution. Thus, attempting to divide by zero does not cause
an abrupt run-time error resulting in the termination of the program. Instead, it is handled
gracefully, allowing program execution to continue.


___

#### Using Multiple catch Statements

you can associate more than one catch statement with a try. In fact, it is
common to do so. However, each catch must catch a different type of exception.

```java
// Handle error gracefully and continue.
class ExcDemo4 
{
	public static void main(String[] args) 
	{
		int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };  // longer than denum
		int[] denum = { 2, 0, 4, 4, 0, 8 };
		
		for(int i=0; i<numer.length; i++) 
		{
			try 
			{
				System.out.println(numer[i] + " / " +
				denom[i] + " is " +
				numer[i]/denom[i]);
			}
			catch (ArithmeticException exc) 
			{
				// catch the exception
				System.out.println("Can't divide by Zero!");
			}
			catch (ArrayIndexOutOfBoundsException exc)
			{
				System.out.println("No matching element found.");
			}
		}
	}
}
```

```
4 / 2 is 2
Can't divide by Zero!
16 / 4 is 4
32 / 4 is 8
Can't divide by Zero!
128 / 8 is 16
No matching element found.
No matching element found.
```

As the output confirms, each catch statement responds only to its own type of exception.

___

#### Catching Subclass Exceptions

since the superclass
of all exceptions is Throwable, to catch all possible exceptions, catch Throwable. If you want
to catch exceptions of both a superclass type and a subclass type, put the subclass first in the
catch sequence. If you don’t, then the superclass catch will also catch all derived classes. This
rule is self-enforcing because putting the superclass first causes unreachable code to be created, since the subclass catch clause can never execute. 

In Java, unreachable code is an error.

```java
// Handle error gracefully and continue.
class ExcDemo4 
{
	public static void main(String[] args) 
	{
		int[] numer = { 4, 8, 16, 32, 64, 128, 256, 512 };  // longer than denum
		int[] denum = { 2, 0, 4, 4, 0, 8 };
		
		for(int i=0; i<numer.length; i++) 
		{
			try 
			{
				System.out.println(numer[i] + " / " +
				denom[i] + " is " +
				numer[i]/denom[i]);
			}
			catch (ArrayIndexOutOfBoundsException exc)
			{ // catch subclass
				System.out.println("No matching element found.");
			}
			catch (Throwable exc) 
			{ // catch superclass
				System.out.println("Some Exception occured!");
			}
		}
	}
}
```

```
4 / 2 is 2
Some exception occurred.
16 / 4 is 4
32 / 4 is 8
Some exception occurred.
128 / 8 is 16
No matching element found.
No matching element found.
```


____

First, if you add a catch clause
that catches exceptions of type Exception, then you have effectively added a “catch all”
clause to your exception handler that deals with all program-related exceptions. Such a
“catch all” clause might be useful in a situation in which abnormal program termination
must be avoided no matter what occurs. Second, in some situations, an entire category of
exceptions can be handled by the same clause. Catching the superclass of these exceptions
allows you to handle all without duplicated code.

___


#### Try blocks can be nested

Often nested try blocks are used to allow
different categories of errors to be handled in different ways. Some types of errors are
catastrophic and cannot be fixed. Some are minor and can be handled immediately. You might
use an outer try block to catch the most severe errors, allowing inner try blocks to handle less
serious ones.

___
